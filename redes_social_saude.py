# -*- coding: utf-8 -*-
"""Redes_Social_Saude.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/112K20waR_3POxOVgWq6fd5cUAidnkgeF

#Bibliotecas#
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
!pip install scikit-learn
from sklearn.model_selection import train_test_split
import plotly.express as px

"""#Dataset#"""

df = pd.read_csv('/content/Questionario - Respostas ao formul√°rio 1 (1).csv')

df

"""#Tratamento dos dados#"""

# Nome das colunas disponiveis no dataset
print("\n Colunas dispon√≠veis no dataset:")
print(df.columns.tolist())

# Renomear colunas
colunas_renomeadas = {
    'Carimbo de data/hora': 'timestamp',
    'Qual sua idade? ': 'idade',
    'Qual sua ocupa√ß√£o atualmente?': 'ocupacao',
    'Voc√™ usa redes sociais?': 'uso_redes',
    'Qual seu status de relacionamento?': 'status_relacionamento',
    'Quantas horas por dia em m√©dia voc√™ utiliza redes sociais? ': 'tempo_redes',
    'Selecione todas as plataformas voc√™ usa frequentemente.': 'plataformas_usadas',
    'Qual o principal motivo pelo qual voc√™ usa redes sociais?': 'motivo_redes',
    'Voc√™ acha que as redes sociais afetam sua produtividade no trabalho/estudo?': 'impacto_produtividade',
    'Voc√™ acha que as redes sociais afetam sua autoestima?': 'impacto_autoestima',
    'Voc√™ gostaria de diminuir seu tempo gasto nas redes sociais?': 'diminuir_tempo',
    'Quantas vezes por semana voc√™ pratica exerc√≠cios f√≠sicos? ': 'freq_exercicio',
    'Numa escala 1 a 5, com que frequ√™ncia voc√™ enfrenta problemas relacionados ao sono?\n\n1 - Nunca\n2 - Raramente\n3 - As vezes\n4 - Frequentemente\n5 - Sempre': 'prob_sono',
    'Numa escala 1 a 5, qu√£o frequente voc√™ se percebe usando redes sociais sem um prop√≥sito espec√≠fico?\n\n1 - Nunca\n2 - Raramente\n3 - As vezes\n4 - Frequentemente\n5 - Sempre': 'uso_sem_proposito',
    'Numa escala 1 a 5, com que frequ√™ncia voc√™ sente sua mente agitada e inquieta?\n\n1 - Nunca\n2 - Raramente\n3 - As vezes\n4 - Frequentemente\n5 - Sempre': 'mente_agitada',
    'Numa escala de 1 a 5, com que frequ√™ncia voc√™ se compara com outras pessoas atrav√©s das redes sociais? \n\n1 - Nunca\n2 - Raramente\n3 - As vezes\n4 - Frequentemente\n5 - Sempre': 'comparacao_social',
    'Numa escala de 1 a 5, com que frequ√™ncia voc√™ se distrai com redes sociais quando est√° ocupado fazendo algo?\n\n1 - Nunca\n2 - Raramente\n3 - As vezes\n4 - Frequentemente\n5 - Sempre': 'distracao_redes',
    'Numa escala de 1 a 5, com que frequ√™ncia voc√™ se sente desmotivado e/ou desanimado?\n\n1 - Nunca\n2 - Raramente\n3 - As vezes\n4 - Frequentemente\n5 - Sempre': 'desmotivacao',
    'Numa escala de 1 a 5, como voc√™ considera seu n√≠vel de estresse?\n\n1 - Nenhum\n2 - Baixo \n3 - Moderado\n4 - Alto\n5 - Muito alto ': 'nivel_estresse',
    'Numa escala de 1 a 5, quanto voc√™ acha que as redes sociais impactam sua sa√∫de mental?\n\n1 - Nenhum\n2 - Baixo \n3 - Moderado\n4 - Alto\n5 - Muito alto ': 'impacto_saude_mental',
    'Marque todas as doen√ßas/problemas nas quais voc√™ sente que foram desenvolvidas ou pioradas pelo uso das redes sociais ': 'problemas_saude',
    'Na sua opini√£o, o que voc√™ faria para melhorar sua rela√ß√£o com as redes sociais? (Caso queira melhorar)': 'melhoria_uso',
    'Na sua opini√£o, de que forma o uso das redes sociais afetam ou podem afetar sua sa√∫de mental e f√≠sica?': 'efeitos_saude'
}

df.rename(columns=colunas_renomeadas, inplace=True)

df.head()

print(df.columns.tolist())

"""#Analise explorat√≥ria#"""

# Conferir valores nulos
df.isnull().sum()

"""### Distribui√ß√£o tempo redes"""

# Informa√ß√µes da coluna tempo_redes
df['tempo_redes'].describe()

# Gr√°fico boxplot da distribui√ß√£o da coluna tempo_redes
fig = px.box(df, x='tempo_redes', title="Boxplot do Tempo em Redes Sociais")
fig.update_layout(
    yaxis_title="",
    xaxis_title="Horas por dia",
    xaxis=dict(tickmode='linear'),  # Aparecer todos os valores do eixo x
    plot_bgcolor="white"
)
fig.show()

# Contar quantas pessoas em cada tempo
df_contagem = df['tempo_redes'].value_counts().sort_index().reset_index()
df_contagem.columns = ['tempo_redes', 'count']  # Renomear colunas para evitar erro

# Criar o gr√°fico de barras
fig = px.bar(df_contagem, x='tempo_redes', y='count',
             labels={'tempo_redes': 'Horas por dia', 'count': 'N√∫mero de pessoas'},
             title='N√∫mero de Pessoas por Tempo em Redes Sociais')

fig.update_layout(
    xaxis=dict(tickmode='linear'),  # for√ßa todos os r√≥tulos no eixo X
    plot_bgcolor='white'
)
fig.show()

"""### M√©dia tempo rede por idade"""

# Verificar m√©dia
df_media_idade = df.groupby('idade', as_index=False)['tempo_redes'].mean()
df_media_idade.head()

#2 colunas
grafico = px.histogram(df_media_idade, x='idade', color='tempo_redes', text_auto= True )
grafico.show()

grafico = px.histogram(df_media_idade, x='idade', y='tempo_redes', text_auto=True, title = 'an√°lise m√©dia de tempo de uso por idade')
grafico.show()

"""### M√©dia tempo de rede por status de relacionamento"""

df_media_casados = df.groupby('status_relacionamento', as_index=False)['tempo_redes'].mean()
df_media_casados.head()

grafico = px.histogram(df_media_casados, x='status_relacionamento', y='tempo_redes', text_auto=True)
grafico.show()

"""### Conserto da coluna motivo redes"""

grafico = px.histogram(df, x='motivo_redes', text_auto= True )
grafico.show()

df_explodido = df.assign(motivo_redes=df['motivo_redes'].str.split(', ')).explode('motivo_redes')
df_explodido.head(3)

#1 coluna
grafico = px.histogram(df_explodido, x='motivo_redes', text_auto= True, title = 'Quantidade de pessoas que marcaram cada um dos motivos (Multipla escolha)' )
grafico.show()

import plotly.express as px

grafico = px.histogram(
    df_explodido,
    x='motivo_redes',
    text_auto=True,
    color_discrete_sequence=["#1f77b4"]  # azul igual ao da barra "Estudante"
)

grafico.update_layout(
    title_text="",
    xaxis_title="",
    yaxis_title="",
    showlegend=False,
    plot_bgcolor="white",
    paper_bgcolor="white"
)

grafico.show()









#2 colunas
grafico = px.histogram(df, x='tempo_redes', color='impacto_produtividade', text_auto= True )
grafico.show()



grafico = px.histogram(df, x='tempo_redes', color='impacto_autoestima', text_auto= True )
grafico.show()







plt.figure(figsize=(8, 6))
df["idade"].value_counts().plot.pie(autopct="%1.1f%%", colors=sns.color_palette("coolwarm", 8))
plt.title("Distribui√ß√£o de Idade")
plt.ylabel("")
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(8, 6))
cores = sns.color_palette("Blues_d", df["idade"].nunique())

df["idade"].value_counts().plot.pie(
    autopct="%1.1f%%",
    colors=cores
)

plt.title("")      # remove o t√≠tulo
plt.ylabel("")     # remove o eixo y
plt.tight_layout() # melhora o layout
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10, 5))
N = df["ocupacao"].nunique()

sns.countplot(
    y=df["ocupacao"],
    order=df["ocupacao"].value_counts().index,
    palette=sns.color_palette("Blues", n_colors=N)
)

plt.title("Distribui√ß√£o por Ocupa√ß√£o")
plt.xlabel("N√∫mero de Respondentes")
plt.ylabel("Ocupa√ß√£o")
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10, 5))
N = df["ocupacao"].nunique()

sns.countplot(
    y=df["ocupacao"],
    order=df["ocupacao"].value_counts().index,
    palette=sns.color_palette("Blues_d", n_colors=N)  # "_d" = darker/more saturated tones
)

# Remover t√≠tulo e nomes dos eixos
plt.title("")
plt.xlabel("")
plt.ylabel("")

# Remover as bordas do gr√°fico
sns.despine(left=True, bottom=True)

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Agrupar categorias similares
df["ocupacao_agrupada"] = df["ocupacao"].replace({
    "Aposentado": "Aposentado(a)",
    "Aposentada": "Aposentado(a)",
    "Professora aposentada": "Aposentado(a)",
    "M√©dico aposentado": "Aposentado(a)",
    # Agrupar profiss√µes raras em "Outros"
    "Conselheiro": "Outros",
    "Advogado": "Outros"
})

# Categorias com poucas ocorr√™ncias agrupadas automaticamente
ocorrencias = df["ocupacao_agrupada"].value_counts()
categorias_principais = ocorrencias[ocorrencias >= 5].index  # ajust√°vel

df["ocupacao_agrupada"] = df["ocupacao_agrupada"].apply(
    lambda x: x if x in categorias_principais else "Outros"
)

# Plot
plt.figure(figsize=(10, 5))
N = df["ocupacao_agrupada"].nunique()

sns.countplot(
    y=df["ocupacao_agrupada"],
    order=df["ocupacao_agrupada"].value_counts().index,
    palette=sns.color_palette("Blues_d", n_colors=N)
)

# Limpar o visual
plt.title("")
plt.xlabel("")
plt.ylabel("")
sns.despine(left=True, bottom=True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(7, 5))
df["uso_redes"].value_counts().plot.pie(autopct="%1.1f%%", colors=["lightblue", "pink"])
plt.title("Propor√ß√£o de Usu√°rios de Redes Sociais")
plt.ylabel("")
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns


sns.set_theme(style="whitegrid")


plt.figure(figsize=(8, 5))
sns.countplot(x=df['status_relacionamento'], palette="Blues_r")


plt.title("Distribui√ß√£o do Status de Relacionamento")
plt.xlabel("Status de Relacionamento")
plt.ylabel("Contagem")
plt.xticks(rotation=45)
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(8, 5))

# N√∫mero de categorias distintas
N = df["status_relacionamento"].nunique()

# Gr√°fico horizontal com paleta azul escura
sns.countplot(
    y=df['status_relacionamento'],
    order=df['status_relacionamento'].value_counts().index,
    palette=sns.color_palette("Blues_d", n_colors=N)
)

# Remover elementos visuais
plt.title("")       # sem t√≠tulo
plt.xlabel("")      # sem nome do eixo x
plt.ylabel("")      # sem nome do eixo y
sns.despine(left=True, bottom=True)  # remove bordas

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(8, 5))

# N√∫mero de categorias distintas
N = df["status_relacionamento"].nunique()

# Gr√°fico de barras verticais
sns.countplot(
    x=df['status_relacionamento'],
    order=df['status_relacionamento'].value_counts().index,
    palette=sns.color_palette("Blues_d", n_colors=N)
)

# Remover t√≠tulo e eixos
plt.title("")       # sem t√≠tulo
plt.xlabel("")      # sem nome do eixo x
plt.ylabel("")      # sem nome do eixo y
plt.xticks(rotation=45)  # rotacionar os r√≥tulos do eixo x
sns.despine(left=True, bottom=True)  # remove bordas

plt.tight_layout()
plt.show()





import matplotlib.pyplot as plt
import seaborn as sns


sns.set_theme(style="whitegrid")


plataformas = df['plataformas_usadas'].str.get_dummies(sep=', ').sum().sort_values(ascending=False)


plt.figure(figsize=(10, 5))
sns.barplot(x=plataformas.index, y=plataformas.values, palette="Blues_r")


plt.title("Plataformas de Redes Sociais Mais Utilizadas")
plt.xlabel("Plataformas")
plt.ylabel("N√∫mero de Usu√°rios")
plt.xticks(rotation=45)


plt.show()

import matplotlib.pyplot as plt
import seaborn as sns


sns.set_theme(style="whitegrid")
media_horas = df.groupby('tempo_redes')['tempo_redes'].count()

plt.figure(figsize=(8, 5))
sns.barplot(x=media_horas.index, y=media_horas.values, palette="Blues_r")

plt.title("M√©dia de Horas de Uso de Redes Sociais por Dia")
plt.xlabel("Horas por Dia")
plt.ylabel("N√∫mero de Usu√°rios")
plt.xticks(rotation=0)

plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

sns.set_theme(style="whitegrid")
produtividade = df['impacto_produtividade'].value_counts()

plt.figure(figsize=(8, 5))
sns.barplot(x=produtividade.index, y=produtividade.values, palette="Blues_r")

plt.title("Impacto do Uso das Redes Sociais na Produtividade")
plt.xlabel("Impacto na Produtividade")
plt.ylabel("N√∫mero de Usu√°rios")
plt.xticks(rotation=45)
plt.show()

"""Enviei at√© aqui"""

import matplotlib.pyplot as plt
import seaborn as sns

sns.set_theme(style="whitegrid")
autoestima = df['impacto_autoestima'].value_counts()


plt.figure(figsize=(8, 5))
sns.barplot(x=autoestima.index, y=autoestima.values, palette="Blues_r")


plt.title("Impacto do Uso das Redes Sociais na Autoestima")
plt.xlabel("Impacto na Autoestima")
plt.ylabel("N√∫mero de Usu√°rios")
plt.xticks(rotation=45)
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns


sns.set_theme(style="whitegrid")
diminuir_tempo = df['diminuir_tempo'].value_counts()


plt.figure(figsize=(8, 5))
sns.barplot(x=diminuir_tempo.index, y=diminuir_tempo.values, palette="Blues_r")

plt.title("Desejo de Diminuir o Tempo nas Redes Sociais")
plt.xlabel("Deseja Diminuir o Tempo?")
plt.ylabel("N√∫mero de Usu√°rios")
plt.xticks(rotation=0)
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns


sns.set_theme(style="whitegrid")
exercicios = df['freq_exercicio'].value_counts().sort_index()

plt.figure(figsize=(8, 5))
sns.barplot(x=exercicios.index, y=exercicios.values, palette="Blues_r")

plt.title("Frequ√™ncia de Pr√°tica de Exerc√≠cios F√≠sicos")
plt.xlabel("Vezes por Semana")
plt.ylabel("N√∫mero de Usu√°rios")
plt.xticks(rotation=0)
plt.show()



"""Correla√ß√£o entre as variaveis numericas"""

colunas_numericas = df.select_dtypes(include=['int64', 'float64'])

correlacao = colunas_numericas.corr()

plt.figure(figsize=(10, 6))
sns.heatmap(correlacao, annot=True, cmap="coolwarm", fmt=".2f", linewidths=0.5)
plt.title("Matriz de Correla√ß√£o das Vari√°veis Num√©ricas")
plt.show()



"""Grafico para pergunta de coisas masi afewtasdas"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Passo 1: Remover nulos e padronizar para min√∫sculas + remover espa√ßos
problemas = df['problemas_saude'].dropna().str.lower().str.strip()

# Passo 2: Separar m√∫ltiplas respostas e limpar espa√ßos
problemas_explodido = problemas.str.split(',').explode().str.strip()

# Passo 3: Contar os problemas mais frequentes
frequencia = problemas_explodido.value_counts().head(10)

# Passo 4: Plotar gr√°fico de barras
plt.figure(figsize=(10, 5))
sns.barplot(x=frequencia.values, y=frequencia.index, palette="Blues_r")
plt.title("Top 10 Problemas de Sa√∫de Relacionados √†s Redes Sociais")
plt.xlabel("N√∫mero de Pessoas")
plt.ylabel("Problema Relatado")
plt.tight_layout()
plt.show()







"""#Clusteriza√ß√£o (K-means)#"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import seaborn as sns

print("Valores ausentes por coluna:")
print(df.isnull().sum())

df = df.drop(columns=[
    'motivo_redes', 'plataformas_usadas', 'ocupacao', 'timestamp',
    'problemas_saude', 'efeitos_saude', 'melhoria_uso'
])

scaler = StandardScaler()
df_scaled = scaler.fit_transform(df.select_dtypes(include=['int64', 'float64']))

wcss = []
k_values = range(1, 11)

for k in k_values:
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(df_scaled)
    wcss.append(kmeans.inertia_)

plt.figure(figsize=(8, 5))
plt.plot(k_values, wcss, marker='o', linestyle='--')
plt.xlabel('N√∫mero de Clusters')
plt.ylabel('WCSS')
plt.title('M√©todo do Cotovelo')
plt.grid(True)
plt.show()

from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

wcss = []
k_values = range(1, 11)

for k in k_values:
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(df_scaled)
    wcss.append(kmeans.inertia_)

# N√∫mero de clusters escolhido
k_escolhido = 3

plt.figure(figsize=(8, 5))
plt.plot(k_values, wcss, marker='o', linestyle='--', color='#2b68ad', label='WCSS')

# Destaque com um X maior e mais vis√≠vel
plt.scatter(
    k_escolhido,
    wcss[k_escolhido - 1],
    color='red',
    marker='X',
    s=200,
    edgecolors='black',
    linewidths=1.5,
    label=f'k = {k_escolhido}'
)

plt.xlabel('N√∫mero de Clusters')
plt.ylabel('WCSS')
plt.grid(True)
plt.legend()
plt.show()

pca = PCA(n_components=3)
df_pca = pca.fit_transform(df_scaled)

kmeans = KMeans(n_clusters=3, random_state=42)

df["cluster"] = kmeans.fit_predict(df_pca)

print("Distribui√ß√£o dos clusters:")
print(df["cluster"].value_counts())

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10, 6))

# Cores: azul claro, azul escuro e azul m√©dio (caso haja 3 clusters)
cores = {0: "orange", 1: "#284bbf", 2: "Green"}

nomes_clusters = {0: "Perfil A", 1: "Perfil B", 2: "Perfil C"}

# Gr√°fico dos clusters com as cores novas
sns.scatterplot(
    x=df_pca[:, 0],
    y=df_pca[:, 1],
    hue=df["cluster"],
    palette=cores
)

# Legenda personalizada
handles = [
    plt.Line2D([0], [0], marker='o', color='w',
               markerfacecolor=cores[i], markersize=10,
               label=f"Cluster {i} - {nomes_clusters[i]}")
    for i in df["cluster"].unique()
]

plt.legend(title="Clusters", handles=handles)

plt.grid(False)
plt.show()

#fazer PCA e mudar cores

media_por_cluster = df.groupby('cluster').mean(numeric_only=True)
print(media_por_cluster.T)







"""Ver m√©dia das variaveis para cada perfil"""

df

"""Percentual das variaveis categoricas por peril"""

pd.crosstab(df['idade'], df['cluster'], normalize='columns') * 100

pd.crosstab(df['impacto_autoestima'], df['cluster'], normalize='columns') * 100

pd.crosstab(df['impacto_produtividade'], df['cluster'], normalize='columns') * 100

pd.crosstab(df['diminuir_tempo'], df['cluster'], normalize='columns') * 100

pd.crosstab(df['status_relacionamento'], df['cluster'], normalize='columns') * 100



df.groupby('cluster')[[
    'tempo_redes', 'freq_exercicio', 'prob_sono',
    'uso_sem_proposito', 'mente_agitada', 'comparacao_social',
    'distracao_redes', 'desmotivacao', 'nivel_estresse',
    'impacto_saude_mental'
]].mean()

import pandas as pd

# Dados simulados (voc√™ deve trocar esses valores pelos reais do seu dataframe)
dados = {
    'Vari√°vel': [
        'Tempo em redes', 'Frequ√™ncia de exerc√≠cio', 'Problema com sono', 'Uso sem prop√≥sito',
        'Mente agitada', 'Compara√ß√£o social', 'Distra√ß√£o nas redes', 'Desmotiva√ß√£o',
        'N√≠vel de estresse', 'Impacto sa√∫de mental'
    ],
    'Cluster 0': [3.28, 3.49, 2.23, 2.66, 2.82, 1.60, 2.22, 2.18, 2.56, 1.76],
    'Cluster 1': [5.07, 1.39, 3.61, 4.29, 4.55, 3.82, 3.86, 3.89, 4.20, 4.18],
    'Cluster 2': [3.82, 3.40, 2.92, 3.73, 3.91, 2.68, 3.04, 2.81, 3.18, 3.00]
}

# Cria o DataFrame
df_tabela = pd.DataFrame(dados)

# Define a vari√°vel como √≠ndice (fica como primeira coluna)
df_tabela.set_index('Vari√°vel', inplace=True)

# Exibe a tabela
print(df_tabela)

# Se quiser salvar como Excel ou CSV:
# df_tabela.to_excel('tabela_clusters.xlsx')
# df_tabela.to_csv('tabela_clusters.csv')





"""#Analise texto##"""

df.head()

import nltk
nltk.download('punkt')
nltk.download('stopwords')

!pip install -U spacy
!python -m spacy download pt_core_news_sm

# Carregar o CSV em uma vari√°vel TEMPOR√ÅRIA
df_texto = pd.read_csv('/content/Questionario - Respostas ao formul√°rio 1 (1).csv')

# Renomear colunas
df_texto.rename(columns=colunas_renomeadas, inplace=True)

# Adicionar apenas as colunas de texto de volta ao df com cluster
colunas_texto = ['problemas_saude', 'efeitos_saude', 'melhoria_uso']
df[colunas_texto] = df_texto[colunas_texto]

df

import spacy
import pandas as pd

# Carregar o modelo de portugu√™s
nlp = spacy.load("pt_core_news_sm")

# Exemplo: assumindo que seu DataFrame j√° est√° carregado como `df`
# e a coluna da primeira pergunta se chama `melhoria_uso`

# Remover valores nulos
df = df.dropna(subset=['melhoria_uso'])

# Fun√ß√£o de limpeza + tokeniza√ß√£o
def preprocessar(texto):
    doc = nlp(texto.lower())
    tokens = [token.lemma_ for token in doc if token.is_alpha and not token.is_stop]
    return tokens

# Aplicar
df['tokens_melhoria'] = df['melhoria_uso'].apply(preprocessar)

# Ver resultado
df[['melhoria_uso', 'tokens_melhoria']].head()

from wordcloud import WordCloud
import matplotlib.pyplot as plt

# Junta todos os tokens em um √∫nico texto
texto = " ".join([token for lista in df['tokens_melhoria'] for token in lista])

# Gera a nuvem de palavras com colormap azul
wordcloud = WordCloud(
    width=800,
    height=400,
    background_color='white',
    colormap='Blues'  # <- Aqui est√° a mudan√ßa
).generate(texto)

# Exibe a nuvem de palavras
plt.figure(figsize=(10, 5))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.title("Nuvem de Palavras - Melhoria no Uso das Redes Sociais")
plt.show()

from collections import Counter

todos_tokens = df['tokens_melhoria'].sum()

# Conta a frequ√™ncia
frequencia = Counter(todos_tokens)

frequencia.most_common(20)

# Define temas e palavras associadas
temas = {
    'reduzir_tempo': ['diminuir', 'menos', 'tempo', 'reduzir', 'limitar'],
    'uso_consciente': ['controlar', 'organizar', 'melhorar', 'uso', 'evitar'],
    'trabalho_estudo': ['trabalho', 'estudo', 'profissional'],
    'apps_especificos': ['instagram', 'tiktok', 'whatsapp', 'celular']
}

# Fun√ß√£o para mapear tokens em temas
def mapear_temas(tokens):
    temas_encontrados = set()
    for token in tokens:
        for tema, palavras in temas.items():
            if token in palavras:
                temas_encontrados.add(tema)
    return list(temas_encontrados)

# Aplica ao DataFrame
df['temas_melhoria'] = df['tokens_melhoria'].apply(mapear_temas)

# Visualiza
df[['melhoria_uso', 'temas_melhoria']].head(10)

from itertools import chain

# Junta todos os temas numa lista √∫nica
todos_os_temas = list(chain.from_iterable(df['temas_melhoria']))

# Conta a frequ√™ncia
contagem_temas = Counter(todos_os_temas)

# Mostra os temas mais citados
contagem_temas.most_common()

import matplotlib.pyplot as plt

import nltk
from nltk.corpus import stopwords

# Plot
plt.figure(figsize=(8,5))
plt.bar(contagem_temas.keys(), contagem_temas.values(), color='#2b68ad')
plt.ylabel('Frequ√™ncia')
plt.xticks(rotation=45)

plt.tight_layout()
plt.show()



"""pergunta dois"""

categorias = {
    'ansiedade': ['ansiedade', 'ansioso', 'ansiosa'],
    'sono': ['sono', 'dormir', 'ins√¥nia', 'cansa√ßo', 'dormindo'],
    'produtividade': ['produtividade', 'procrastina√ß√£o', 'foco', 'distra√ß√£o', 'concentra√ß√£o'],
    'humor': ['tristeza', 'depress√£o', 'estresse', 'estressado', 'raiva'],
    'autoimagem': ['autoestima', 'imagem', 'compara√ß√£o', 'autoconfian√ßa'],
    'relacionamentos': ['relacionamentos', 'isolamento', 'solid√£o', 'conex√µes', 'amizades'],
    'atividade f√≠sica': ['sedentarismo', 'exerc√≠cio', 'atividade', 'movimento'],
}

import pandas as pd
import re
import matplotlib.pyplot as plt
from collections import Counter
from nltk.corpus import stopwords
import nltk

# Baixar stopwords se necess√°rio
nltk.download('stopwords')
stopwords_pt = set(stopwords.words('portuguese'))

# Carrega o DataFrame
df= df.dropna(subset=['efeitos_saude'])

# Fun√ß√£o de pr√©-processamento
def preprocessar_texto(texto):
    texto = texto.lower()
    texto = re.sub(r'[^\w\s]', '', texto)
    palavras = texto.split()
    palavras = [p for p in palavras if p not in stopwords_pt]
    return palavras

# Aplica a limpeza e junta todas as palavras
todas_palavras = []
for texto in df['efeitos_saude']:
    palavras = preprocessar_texto(texto)
    todas_palavras.extend(palavras)

# Contagem de palavras
contador = Counter(todas_palavras)
mais_comuns = contador.most_common(50)

# Visualiza√ß√£o simples dos 20 mais frequentes
palavras, frequencias = zip(*mais_comuns[:20])
plt.figure(figsize=(12, 6))
plt.barh(palavras[::-1], frequencias[::-1], color='skyblue')
plt.title('üîç Palavras mais mencionadas sobre os efeitos na sa√∫de')
plt.xlabel('Frequ√™ncia')
plt.tight_layout()
plt.show()

# Criar um contador por categoria
contagem_categorias = {categoria: 0 for categoria in categorias}

# Verifica presen√ßa de palavras associadas nas respostas
for texto in df['efeitos_saude']:
    palavras = preprocessar_texto(texto)
    for categoria, termos in categorias.items():
        if any(p in palavras for p in termos):
            contagem_categorias[categoria] += 1

# Visualizar como gr√°fico
import matplotlib.pyplot as plt

categorias_ordenadas = sorted(contagem_categorias.items(), key=lambda x: x[1], reverse=True)
labels, valores = zip(*categorias_ordenadas)

plt.figure(figsize=(10, 5))
plt.barh(labels[::-1], valores[::-1], color='mediumpurple')
plt.xlabel('N√∫mero de men√ß√µes')
plt.title('üéØ Temas de sa√∫de mais afetados segundo os relatos')
plt.tight_layout()
plt.show()



import matplotlib.pyplot as plt
import numpy as np

# Mapeamento para exibir nomes mais formais no gr√°fico
nomes_formais = {
    'ansiedade': 'Ansiedade',
    'sono': 'Qualidade do sono',
    'produtividade': 'Produtividade',
    'humor': 'Humor e emo√ß√µes',
    'autoimagem': 'Autoimagem e autoestima',
    'relacionamentos': 'Relacionamentos sociais',
    'atividade f√≠sica': 'Atividade f√≠sica',
}

# Ordenar categorias por frequ√™ncia
categorias_ordenadas = sorted(contagem_categorias.items(), key=lambda x: x[1], reverse=True)
labels, valores = zip(*categorias_ordenadas)
labels_formatados = [nomes_formais[label] for label in labels]

# Gradiente de azul
cores = plt.cm.Blues(np.linspace(0.4, 0.9, len(labels)))

# Plot do gr√°fico
plt.figure(figsize=(10, 6))
barras = plt.barh(labels_formatados[::-1], valores[::-1], color=cores[::-1])
plt.xlabel('N√∫mero de men√ß√µes')
plt.title('Sintomas associados ao uso excessivo das redes sociais', fontsize=14)
plt.gca().invert_yaxis()  # mais citado no topo

# R√≥tulos com valores nas barras
for barra in barras:
    plt.text(barra.get_width() + 0.3, barra.get_y() + 0.25,
             str(barra.get_width()), va='center', fontsize=10)

# Remover bordas superiores e laterais
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

plt.tight_layout()
plt.show()





"""#Correlacionar as colunas abertas por cluster"""

df





#reaproveitar copm clusters

#com dados normalizados

import pandas as pd
import matplotlib.pyplot as plt
import re
from collections import Counter
from nltk.corpus import stopwords
import nltk

# üîΩ Apenas na primeira vez
nltk.download('stopwords')
stopwords_pt = set(stopwords.words('portuguese'))

# üìå Fun√ß√£o de pr√©-processamento
def preprocessar_texto(texto):
    texto = texto.lower()
    texto = re.sub(r'[^\w\s]', '', texto)
    palavras = texto.split()
    palavras = [p for p in palavras if p not in stopwords_pt]
    return palavras

# üìå Temas e palavras associadas
categorias = {
    'ansiedade': ['ansiedade', 'ansioso', 'ansiosa'],
    'sono': ['sono', 'dormir', 'ins√¥nia', 'cansa√ßo', 'dormindo'],
    'produtividade': ['produtividade', 'procrastina√ß√£o', 'foco', 'distra√ß√£o', 'concentra√ß√£o'],
    'humor': ['tristeza', 'depress√£o', 'estresse', 'estressado', 'raiva'],
    'autoimagem': ['autoestima', 'imagem', 'compara√ß√£o', 'autoconfian√ßa'],
    'relacionamentos': ['relacionamentos', 'isolamento', 'solid√£o', 'conex√µes', 'amizades'],
    'atividade f√≠sica': ['sedentarismo', 'exerc√≠cio', 'atividade', 'movimento'],
}

# üß† Contagem bruta por cluster
contagem_por_cluster = {
    c: {categoria: 0 for categoria in categorias}
    for c in sorted(df['cluster'].unique())
}

for _, linha in df.iterrows():
    texto = str(linha['efeitos_saude'])
    palavras = preprocessar_texto(texto)
    c = linha['cluster']
    for categoria, termos in categorias.items():
        if any(p in palavras for p in termos):
            contagem_por_cluster[c][categoria] += 1

# üìä DataFrame de contagem absoluta
df_bruto = pd.DataFrame(contagem_por_cluster).T
df_bruto.index.name = 'cluster'

# üìä Normaliza√ß√£o (% de participantes por cluster)
tamanho_cluster = df['cluster'].value_counts().to_dict()
df_normalizado = df_bruto.copy()
for c in df_normalizado.index:
    df_normalizado.loc[c] = (df_normalizado.loc[c] / tamanho_cluster[c]) * 100

# üé® Cores por cluster
cores_clusters = {
    0: '#FFA500',  # Laranja ‚Äì Perfil A
    1: '#1E90FF',  # Azul ‚Äì Perfil B
    2: '#228B22',  # Verde ‚Äì Perfil C
}

# üîÑ Ordena os temas pelo total normalizado (soma dos %)
ordem = df_normalizado.sum(axis=0).sort_values(ascending=False).index
df_plot = df_normalizado[ordem].T  # Transp√µe para plotar horizontalmente

# üìà Gr√°fico de barras horizontais com r√≥tulos
ax = df_plot.plot(
    kind='barh',
    figsize=(10, 6),
    color=[cores_clusters[c] for c in df_plot.columns],
    edgecolor='black'
)

plt.title('üéØ Temas de sa√∫de afetados por cluster (em %)', fontsize=14)
plt.xlabel('Percentual de participantes no cluster (%)')
plt.ylabel('Categoria')
plt.grid(axis='x', linestyle='--', alpha=0.3)

# ‚ûï R√≥tulos nas barras
for bars in ax.containers:
    for bar in bars:
        width = bar.get_width()
        if width > 0:
            ax.text(width + 0.5, bar.get_y() + bar.get_height()/2,
                    f"{width:.1f}%", va='center', fontsize=9)

# üßæ Legenda personalizada
from matplotlib.patches import Patch
legenda = [
    Patch(color=cores_clusters[0], label='Cluster 0 - Perfil A'),
    Patch(color=cores_clusters[1], label='Cluster 1 - Perfil B'),
    Patch(color=cores_clusters[2], label='Cluster 2 - Perfil C'),
]
plt.legend(handles=legenda, title='Perfis', loc='upper right')

plt.tight_layout()
plt.show()











from matplotlib.patches import Patch
from collections import Counter
from itertools import chain
import pandas as pd

# üé® Cores por cluster (como os gr√°ficos anteriores)
cores_clusters = {
    0: '#FFA500',  # Laranja ‚Äì Perfil A
    1: '#1E90FF',  # Azul ‚Äì Perfil B
    2: '#228B22',  # Verde ‚Äì Perfil C
}

# üß© Lista de clusters presentes
clusters = sorted(df['cluster'].unique())

# üß† Lista padronizada de temas (aparece como eixo X)
temas_padrao = ['reduzir_tempo', 'uso_consciente', 'trabalho_estudo', 'apps_especificos']

# üîÅ Inicializa contagem de temas por cluster
contagem_temas_por_cluster = {
    c: {tema: 0 for tema in temas_padrao}
    for c in clusters
}

# üìå Conta temas por cluster
for _, linha in df.iterrows():
    cluster = linha['cluster']
    for tema in linha['temas_melhoria']:
        if tema in temas_padrao:
            contagem_temas_por_cluster[cluster][tema] += 1

# üìä Converte para DataFrame
df_temas_cluster = pd.DataFrame(contagem_temas_por_cluster).T  # clusters como linhas
df_plot = df_temas_cluster[temas_padrao].T  # temas no eixo X, colunas = clusters

# üìà Cria gr√°fico de barras agrupadas por tema e colorido por cluster
ax = df_plot.plot(
    kind='bar',
    figsize=(10, 6),
    color=[cores_clusters[c] for c in df_plot.columns],
    edgecolor='black'
)

# üè∑Ô∏è Ajustes de estilo
plt.title('üì± Temas mais citados para melhorar o uso do celular (por cluster)', fontsize=14)
plt.ylabel('Frequ√™ncia')
plt.xlabel('Tema')
plt.xticks(rotation=45, ha='right')
plt.grid(axis='y', linestyle='--', alpha=0.4)

# üßæ Legenda por perfil
legenda = [
    Patch(color=cores_clusters[0], label='Cluster 0 - Perfil A'),
    Patch(color=cores_clusters[1], label='Cluster 1 - Perfil B'),
    Patch(color=cores_clusters[2], label='Cluster 2 - Perfil C'),
]
plt.legend(handles=legenda, title='Perfis', loc='upper right')

plt.tight_layout()
plt.show()

# Dicion√°rio para exibir nomes mais claros no gr√°fico
nomes_formatados = {
    'reduzir_tempo': 'Reduzir tempo de uso',
    'uso_consciente': 'Usar de forma mais consciente',
    'trabalho_estudo': 'Focar em trabalho/estudo',
    'apps_especificos': 'Evitar apps espec√≠ficos',
}



import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from collections import Counter
from itertools import chain
import pandas as pd

# üé® Cores por cluster
cores_clusters = {
    0: '#FFA500',  # Laranja ‚Äì Perfil A
    1: '#1E90FF',  # Azul ‚Äì Perfil B
    2: '#228B22',  # Verde ‚Äì Perfil C
}

# üß© Clusters
clusters = sorted(df['cluster'].unique())

# üß† Temas t√©cnicos (originais)
temas_padrao = ['reduzir_tempo', 'uso_consciente', 'trabalho_estudo', 'apps_especificos']

# üîÅ Inicializa contagem de temas por cluster
contagem_temas_por_cluster = {
    c: {tema: 0 for tema in temas_padrao}
    for c in clusters
}

# üìå Conta temas por cluster
for _, linha in df.iterrows():
    cluster = linha['cluster']
    for tema in linha['temas_melhoria']:
        if tema in temas_padrao:
            contagem_temas_por_cluster[cluster][tema] += 1

# üìä Converte para DataFrame
df_temas_cluster = pd.DataFrame(contagem_temas_por_cluster).T
df_plot = df_temas_cluster[temas_padrao].T

# üîÑ Ordena os temas do menor para o maior
df_plot = df_plot.loc[df_plot.sum(axis=1).sort_values(ascending=True).index]

# üìà Cria o gr√°fico
ax = df_plot.plot(
    kind='bar',
    figsize=(10, 6),
    color=[cores_clusters[c] for c in df_plot.columns],
    edgecolor='black'
)

# üè∑Ô∏è Estilo
plt.title('Temas mais citados para melhorar o uso do celular (por cluster)', fontsize=14)
plt.ylabel('Frequ√™ncia')
plt.xlabel('Tema')
plt.xticks(rotation=45, ha='right')
plt.grid(axis='y', linestyle='--', alpha=0.4)

# üßæ Legenda √† esquerda
legenda = [
    Patch(color=cores_clusters[0], label='Cluster 0 - Perfil A'),
    Patch(color=cores_clusters[1], label='Cluster 1 - Perfil B'),
    Patch(color=cores_clusters[2], label='Cluster 2 - Perfil C'),
]
plt.legend(handles=legenda, title='Perfis', loc='upper left')

plt.tight_layout()
plt.show()

# com dados normalizados

import matplotlib.pyplot as plt
from matplotlib.patches import Patch
import pandas as pd

# (mant√©m o restante do seu c√≥digo)

# Garante que as colunas estejam ordenadas para a paleta de cores
df_plot = df_plot[sorted(df_plot.columns)]

ax = df_plot.plot(
    kind='bar',
    figsize=(10, 6),
    color=[cores_clusters[c] for c in df_plot.columns],
    edgecolor='black'
)

plt.title('Temas mais citados para melhorar o uso do celular (por cluster) ‚Äî Percentual', fontsize=14)
plt.ylabel('Percentual (%)')
plt.xlabel('Tema')
plt.xticks(rotation=45, ha='right')
plt.grid(axis='y', linestyle='--', alpha=0.4)

# Corre√ß√£o para r√≥tulos em gr√°fico vertical
for container in ax.containers:
    for bar in container:
        height = bar.get_height()
        if height > 0:
            ax.text(bar.get_x() + bar.get_width() / 2, height + 0.5,
                    f"{height:.1f}%", ha='center', va='bottom', fontsize=9)

legenda = [
    Patch(color=cores_clusters[0], label='Cluster 0 - Perfil A'),
    Patch(color=cores_clusters[1], label='Cluster 1 - Perfil B'),
    Patch(color=cores_clusters[2], label='Cluster 2 - Perfil C'),
]
plt.legend(handles=legenda, title='Perfis', loc='upper left')

plt.tight_layout()
plt.show()

